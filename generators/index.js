const fs = require('fs');
const fetch = require('node-fetch');
const PDFDocument = require('pdfkit');
// eslint-disable-next-line camelcase
const { card_file, card_printing } = require('../database/models');

const TEMP_IMG_PATH = './tmp/images/';
const IMAGE_BASE_DIR = `${process.env.AZURE_BASE_BLOB_URL}/${process.env.AZURE_IMAGES_CONTAINER_NAME}/`;

function cmToPt(cm) {
  return cm * 28.3464566929134;
}

const cardWidth = 6.299;
const cardHeight = 8.788;
const cardWidthPt = cmToPt(cardWidth);
const cardHeightPt = cmToPt(cardHeight);
let progress;

function fileDoesNotExists(path, onExistsMsg, job, progressIncrementUnique) {
  try {
    if (!fs.existsSync(path)) {
      return true;
    }
    console.error(onExistsMsg);
    // job.log(onExistsMsg);
    progress += progressIncrementUnique;
    job.progress(progress);
  } catch (err) {
    console.error(err);
  }
  return false;
}

async function getFileNames(cardList, includeCardBacks) {
  const cardFiles = cardList.map(async (card) => {
    let sourceCol;
    // eslint-disable-next-line default-case
    switch (card.source) {
      case 'lm':
        sourceCol = 'lm_card_file';
        break;
      case 'pt':
        sourceCol = 'pt_card_file';
        break;
      case 'de':
        sourceCol = 'de_card_file';
        break;
    }
    const filenames = await card_printing.findOne({
      attributes: [],
      include: [{
        model: card_file,
        as: sourceCol,
        attributes: ['pdf', 'pdf_back'],
      }],
      where: { code: card.code },
    });
    return {
      pdf: filenames[sourceCol].pdf,
      pdf_back: filenames[sourceCol].pdf_back,
    };
  });
  const filenames = await Promise.all(cardFiles);
  if (includeCardBacks) {
    return filenames
      .reduce((acc, filename) => (acc.concat([filename.pdf, filename.pdf_back])), [])
      .filter((filename) => (filename !== ''));
  }
  return filenames
    .map((filename) => (filename.pdf))
    .filter((filename) => (filename !== ''));
}

async function downloadFiles(fileNames, job, progressIncrementUnique) {
  if (!fs.existsSync(TEMP_IMG_PATH)) { fs.mkdirSync(TEMP_IMG_PATH, { recursive: true }); }
  const promises = fileNames.map(async (fileName) => {
    const filePath = TEMP_IMG_PATH + fileName;
    const url = IMAGE_BASE_DIR + fileName;
    const imgRes = await fetch(url)
      .then((res) => {
        if (!res.ok) {
          throw new Error(`Error downloading: ${fileName}`);
        }
        console.log(`Downloaded ${fileName}`);
        // job.log(`Downloaded ${fileName}`);
        progress += progressIncrementUnique;
        job.progress(progress);
        return res;
      });
    const fileStream = fs.createWriteStream(filePath);
    return new Promise((resolve, reject) => {
      imgRes.body.pipe(fileStream);
      imgRes.body.on('error', (err) => {
        reject(err);
      });
      fileStream.on('finish', () => {
        resolve();
      });
    });
  });
  await Promise.all(promises);
}

function drawCutLines(doc, leftMargin, topMargin) {
  doc.lineWidth(0.5);
  // draw top lines
  let x = cardWidthPt + leftMargin;
  let y = topMargin;
  doc.moveTo(x, y)
    .lineTo(x, y - 10)
    .stroke();
  x += cardWidthPt;
  doc.moveTo(x, y)
    .lineTo(x, y - 10)
    .stroke();

  // draw lines between row 1 and 2
  x = leftMargin;
  y += cardHeightPt;
  doc.moveTo(x, y)
    .lineTo(x - 18, y)
    .stroke();
  x += 3 * cardWidthPt;
  doc.moveTo(x, y)
    .lineTo(x + 18, y)
    .stroke();

  // draw lines between row 2 and 3
  x = leftMargin;
  y += cardHeightPt;
  doc.moveTo(x, y)
    .lineTo(x - 18, y)
    .stroke();
  x += 3 * cardWidthPt;
  doc.moveTo(x, y)
    .lineTo(x + 18, y)
    .stroke();

  // draw bottom lines
  x = cardWidthPt + leftMargin;
  y += cardHeightPt;
  doc.moveTo(x, y)
    .lineTo(x, y + 10)
    .stroke();
  x += cardWidthPt;
  doc.moveTo(x, y)
    .lineTo(x, y + 10)
    .stroke();
}

function drawFullCutLines(doc, leftMargin, topMargin) {
  doc.lineWidth(0.75);
  const greyStroke = '#818181';

  // draw vertical lines
  let x = cardWidthPt + leftMargin;
  let y = 0;
  doc.moveTo(x, y)
    .lineTo(x, y + 1000)
    .stroke(greyStroke);
  x += cardWidthPt;
  doc.moveTo(x, y)
    .lineTo(x, y + 1000)
    .stroke(greyStroke);

  // draw horizontal lines
  x = 0;
  y = cardHeightPt + topMargin;
  doc.moveTo(x, y)
    .lineTo(x + 1000, y)
    .stroke(greyStroke);
  y += cardHeightPt;
  doc.moveTo(x, y)
    .lineTo(x + 1000, y)
    .stroke(greyStroke);
}

function makeFrontPage(doc) {
  doc.moveDown(15);
  doc.fontSize(20);
  doc.text('Generated by Proxy Nexus at https://proxynexus.net', {
    align: 'center',
  });
  doc.moveDown(3);
  doc.fontSize(14);
  doc.text('Print this PDF at 100% size with no additional margins.', {
    align: 'center',
  });
  doc.moveDown(20);
  doc.fontSize(12);
  doc.text(`Generated on: ${new Date().toString()}`, {
    align: 'left',
  });
  doc.addPage();
}

function addImages(lst, doc, leftMargin, topMargin, fullCutLines, job, progressIncrement) {
  let rowCount = 0;
  let colCount = 0;

  for (let i = 0, n = lst.length; i < n; i += 1) {
    const code = lst[i];
    const x = rowCount * cardWidthPt + leftMargin;
    const y = colCount * cardHeightPt + topMargin;
    const imgPath = TEMP_IMG_PATH + code;

    doc.image(imgPath, x, y, { width: cardWidthPt, height: cardHeightPt });
    rowCount += 1;

    console.log(`Added ${code} to PDF`);
    // job.log(`Added ${code} to PDF`);
    progress += progressIncrement;
    job.progress(progress);

    if (rowCount > 2) {
      rowCount = 0;
      colCount += 1;
    }
    if (i === lst.length - 1) {
      if (fullCutLines) {
        drawFullCutLines(doc, leftMargin, topMargin);
      } else {
        drawCutLines(doc, leftMargin, topMargin);
      }
    }
    if (colCount > 2 && i < lst.length - 1) {
      colCount = 0;
      if (fullCutLines) {
        drawFullCutLines(doc, leftMargin, topMargin);
      } else {
        drawCutLines(doc, leftMargin, topMargin);
      }
      doc.addPage();
    }
  }
}

async function generatePdf(job, hash) {
  const {
    cardList,
    includeCardBacks,
    PdfPageSize,
    fullCutLines,
    requestID,
  } = job.data;
  const pdfFileName = `${hash}.pdf`;

  progress = 0;
  const fileNames = await getFileNames(cardList, includeCardBacks);
  const uniqueFileNames = [...new Set(fileNames)];
  const progressIncrementUnique = 50 / uniqueFileNames.length;
  const progressIncrement = 45 / fileNames.length;
  const fileNamesToDownload = uniqueFileNames.filter((fileName) => {
    const filePath = TEMP_IMG_PATH + fileName;
    const onExistsMsg = `Found cached copy of ${fileName}, don't download`;
    return fileDoesNotExists(filePath, onExistsMsg, job, progressIncrementUnique);
  });

  job.log('Fetching images...');
  try {
    await downloadFiles(fileNamesToDownload, job, progressIncrementUnique);
  } catch (err) {
    console.error(err);
  }

  job.log('Adding images to pdf...');
  job.progress(50);

  let leftMargin;
  let topMargin;
  if (PdfPageSize === 'A4') {
    leftMargin = 30;
    topMargin = 46;
  } else if (PdfPageSize === 'Letter') {
    leftMargin = 36;
    topMargin = 21;
  }
  const pdfPath = `./tmp/${pdfFileName}`;
  const doc = new PDFDocument({
    size: 'Letter',
    margins: {
      top: topMargin,
      bottom: topMargin,
      left: leftMargin,
      right: leftMargin,
    },
  });

  const writeStream = fs.createWriteStream(pdfPath);
  doc.pipe(writeStream);
  try {
    makeFrontPage(doc);
  } catch (e) {
    console.log(e);
  }
  addImages(fileNames, doc, leftMargin, topMargin, fullCutLines, job, progressIncrement);
  doc.end();

  await new Promise((resolve) => {
    writeStream.on('finish', () => {
      resolve();
    });
  });

  return {
    filepath: pdfPath,
    hash,
    requestID,
  };
}

async function generateMpc(job, hash) {
  console.log(job.data);
  console.log(hash);
}

module.exports.generatePdf = generatePdf;
module.exports.generateMpc = generateMpc;
