const fs = require('fs');
const fetch = require('node-fetch');
const PDFDocument = require('pdfkit');
const sharp = require('sharp');
const archiver = require('archiver');
// eslint-disable-next-line camelcase
const { card_file, card_printing } = require('../database/models');

const TEMP_IMG_PATH = './tmp/images/';
const IMAGE_BASE_DIR = `${process.env.AZURE_BASE_BLOB_URL}/${process.env.AZURE_IMAGES_CONTAINER_NAME}/`;

function cmToPt(cm) {
  return cm * 28.3464566929134;
}

const cardWidth = 6.299;
const cardHeight = 8.788;
const cardWidthPt = cmToPt(cardWidth);
const cardHeightPt = cmToPt(cardHeight);
let progress;

function fileDoesNotExists(path, onExistsMsg, job, progressIncrementUnique) {
  try {
    if (!fs.existsSync(path)) {
      return true;
    }
    console.error(onExistsMsg);
    // job.log(onExistsMsg);
    progress += progressIncrementUnique;
    job.progress(progress);
  } catch (err) {
    console.error(err);
  }
  return false;
}

async function getFileNames(cardList, includeCardBacks, generateType, lmPlacementType = 'fit') {
  const cardFiles = cardList.map(async (card) => {
    let sourceCol;
    if (card.source === 'lm') { sourceCol = 'lm_card_file'; }
    if (card.source === 'pt') { sourceCol = 'pt_card_file'; }
    if (card.source === 'de') { sourceCol = 'de_card_file'; }
    let attributes;
    if (generateType === 'pdf') { attributes = ['pdf', 'pdf_back']; }
    if (generateType === 'mpc') {
      if (lmPlacementType === 'fit') { attributes = ['mpc_fitted', 'mpc_fitted_back']; }
      if (lmPlacementType === 'scale') { attributes = ['mpc_scaled', 'mpc_scaled_back']; }
    }
    const filenames = await card_printing.findOne({
      attributes: [],
      include: [{
        model: card_file,
        as: sourceCol,
        attributes,
      }],
      where: { code: card.code },
    });
    return {
      front: filenames[sourceCol][attributes[0]],
      back: filenames[sourceCol][attributes[1]],
    };
  });
  const filenames = await Promise.all(cardFiles);
  if (includeCardBacks) {
    return filenames
      .reduce((acc, filename) => (acc.concat([filename.front, filename.back])), [])
      .filter((filename) => (filename !== ''));
  }
  return filenames
    .map((filename) => (filename.front))
    .filter((filename) => (filename !== ''));
}

async function downloadFiles(fileNames, job, progressIncrementUnique) {
  if (!fs.existsSync(TEMP_IMG_PATH)) { fs.mkdirSync(TEMP_IMG_PATH, { recursive: true }); }
  const promises = fileNames.map(async (fileName) => {
    const filePath = TEMP_IMG_PATH + fileName;
    const url = IMAGE_BASE_DIR + fileName;
    const imgRes = await fetch(url)
      .then((res) => {
        if (!res.ok) {
          throw new Error(`Error downloading: ${fileName}`);
        }
        console.log(`Downloaded ${fileName}`);
        // job.log(`Downloaded ${fileName}`);
        progress += progressIncrementUnique;
        job.progress(progress);
        return res;
      });
    const fileStream = fs.createWriteStream(filePath);
    return new Promise((resolve, reject) => {
      imgRes.body.pipe(fileStream);
      imgRes.body.on('error', (err) => {
        reject(err);
      });
      fileStream.on('finish', () => {
        resolve();
      });
    });
  });
  await Promise.all(promises);
}

function drawCutLines(doc, leftMargin, topMargin) {
  doc.lineWidth(0.5);
  // draw top lines
  let x = cardWidthPt + leftMargin;
  let y = topMargin;
  doc.moveTo(x, y)
    .lineTo(x, y - 10)
    .stroke();
  x += cardWidthPt;
  doc.moveTo(x, y)
    .lineTo(x, y - 10)
    .stroke();

  // draw lines between row 1 and 2
  x = leftMargin;
  y += cardHeightPt;
  doc.moveTo(x, y)
    .lineTo(x - 18, y)
    .stroke();
  x += 3 * cardWidthPt;
  doc.moveTo(x, y)
    .lineTo(x + 18, y)
    .stroke();

  // draw lines between row 2 and 3
  x = leftMargin;
  y += cardHeightPt;
  doc.moveTo(x, y)
    .lineTo(x - 18, y)
    .stroke();
  x += 3 * cardWidthPt;
  doc.moveTo(x, y)
    .lineTo(x + 18, y)
    .stroke();

  // draw bottom lines
  x = cardWidthPt + leftMargin;
  y += cardHeightPt;
  doc.moveTo(x, y)
    .lineTo(x, y + 10)
    .stroke();
  x += cardWidthPt;
  doc.moveTo(x, y)
    .lineTo(x, y + 10)
    .stroke();
}

function drawFullCutLines(doc, leftMargin, topMargin) {
  doc.lineWidth(0.75);
  const greyStroke = '#818181';

  // draw vertical lines
  let x = cardWidthPt + leftMargin;
  let y = 0;
  doc.moveTo(x, y)
    .lineTo(x, y + 1000)
    .stroke(greyStroke);
  x += cardWidthPt;
  doc.moveTo(x, y)
    .lineTo(x, y + 1000)
    .stroke(greyStroke);

  // draw horizontal lines
  x = 0;
  y = cardHeightPt + topMargin;
  doc.moveTo(x, y)
    .lineTo(x + 1000, y)
    .stroke(greyStroke);
  y += cardHeightPt;
  doc.moveTo(x, y)
    .lineTo(x + 1000, y)
    .stroke(greyStroke);
}

function makeFrontPage(doc) {
  doc.moveDown(15);
  doc.fontSize(20);
  doc.text('Generated by Proxy Nexus at https://proxynexus.net', {
    align: 'center',
  });
  doc.moveDown(3);
  doc.fontSize(14);
  doc.text('Print this PDF at 100% size with no additional margins.', {
    align: 'center',
  });
  doc.moveDown(20);
  doc.fontSize(12);
  doc.text(`Generated on: ${new Date().toString()}`, {
    align: 'left',
  });
  doc.addPage();
}

function addImages(lst, doc, leftMargin, topMargin, fullCutLines, job, progressIncrement) {
  let rowCount = 0;
  let colCount = 0;

  for (let i = 0, n = lst.length; i < n; i += 1) {
    const code = lst[i];
    const x = rowCount * cardWidthPt + leftMargin;
    const y = colCount * cardHeightPt + topMargin;
    const imgPath = TEMP_IMG_PATH + code;

    doc.image(imgPath, x, y, { width: cardWidthPt, height: cardHeightPt });
    rowCount += 1;

    console.log(`Added ${code} to PDF`);
    // job.log(`Added ${code} to PDF`);
    progress += progressIncrement;
    job.progress(progress);

    if (rowCount > 2) {
      rowCount = 0;
      colCount += 1;
    }
    if (i === lst.length - 1) {
      if (fullCutLines) {
        drawFullCutLines(doc, leftMargin, topMargin);
      } else {
        drawCutLines(doc, leftMargin, topMargin);
      }
    }
    if (colCount > 2 && i < lst.length - 1) {
      colCount = 0;
      if (fullCutLines) {
        drawFullCutLines(doc, leftMargin, topMargin);
      } else {
        drawCutLines(doc, leftMargin, topMargin);
      }
      doc.addPage();
    }
  }
}

async function generatePdf(job, hash) {
  const {
    cardList,
    includeCardBacks,
    PdfPageSize,
    fullCutLines,
    requestID,
  } = job.data;
  const pdfFileName = `${hash}.pdf`;

  progress = 0;
  const fileNames = await getFileNames(cardList, includeCardBacks, 'pdf');
  const uniqueFileNames = [...new Set(fileNames)];
  const progressIncrementUnique = 50 / uniqueFileNames.length;
  const progressIncrement = 45 / fileNames.length;
  const fileNamesToDownload = uniqueFileNames.filter((fileName) => {
    const filePath = TEMP_IMG_PATH + fileName;
    const onExistsMsg = `Found cached copy of ${fileName}, don't download`;
    return fileDoesNotExists(filePath, onExistsMsg, job, progressIncrementUnique);
  });

  job.log('Fetching images...');
  try {
    await downloadFiles(fileNamesToDownload, job, progressIncrementUnique);
  } catch (err) {
    console.error(err);
    // TODO cancel job, inform client
  }

  job.log('Adding images to pdf...');
  job.progress(50);

  let leftMargin;
  let topMargin;
  if (PdfPageSize === 'A4') {
    leftMargin = 30;
    topMargin = 46;
  } else if (PdfPageSize === 'Letter') {
    leftMargin = 36;
    topMargin = 21;
  }
  const pdfPath = `./tmp/${pdfFileName}`;
  const doc = new PDFDocument({
    size: 'Letter',
    margins: {
      top: topMargin,
      bottom: topMargin,
      left: leftMargin,
      right: leftMargin,
    },
  });

  const writeStream = fs.createWriteStream(pdfPath);
  doc.pipe(writeStream);
  try {
    makeFrontPage(doc);
  } catch (e) {
    console.log(e);
  }
  addImages(fileNames, doc, leftMargin, topMargin, fullCutLines, job, progressIncrement);
  doc.end();

  await new Promise((resolve) => {
    writeStream.on('finish', () => {
      resolve();
    });
  });

  return {
    filepath: pdfPath,
    hash,
    requestID,
  };
}

async function setRedPixel(originalPath, dupPath, index, completeMsg) {
  return new Promise((resolve, reject) => {
    sharp(originalPath)
      // TODO may need to fetch redDot.png from within worker process
      .composite([{
        input: './misc/redDot.png', blend: 'over', top: index, left: 0,
      }])
      .toFile(dupPath)
      .then(() => {
        console.log(completeMsg);
        resolve();
      })
      .catch((err) => {
        console.log(err);
        reject();
      });
  });
}

async function generateMpc(job, hash) {
  const {
    cardList,
    includeCardBacks,
    LmMpcPlacement,
    requestID,
  } = job.data;
  const zipFileName = `${hash}.zip`;
  const zipPath = `./tmp/${zipFileName}`;
  const zipDir = `./tmp/${hash}/`;

  if (!fs.existsSync(zipDir)) {
    fs.mkdirSync(zipDir, { recursive: true });
    fs.mkdirSync(`${zipDir}runner/`);
    fs.mkdirSync(`${zipDir}corp/`);
  }

  progress = 0;
  const cardListRunner = cardList.filter((card) => (card.side === 'runner'));
  const cardListCorp = cardList.filter((card) => (card.side === 'corp'));

  const fileNamesRunner = await getFileNames(cardListRunner, includeCardBacks, 'mpc', LmMpcPlacement);
  const fileNamesCorp = await getFileNames(cardListCorp, includeCardBacks, 'mpc', LmMpcPlacement);

  const imgCounts = {};
  fileNamesRunner.forEach((fileName) => {
    if (fileName in imgCounts) {
      if (imgCounts[fileName].count < 99) {
        imgCounts[fileName].count += 1;
      }
    } else {
      imgCounts[fileName] = { count: 1, side: 'runner' };
    }
  });
  fileNamesCorp.forEach((fileName) => {
    if (fileName in imgCounts) {
      if (imgCounts[fileName].count < 99) {
        imgCounts[fileName].count += 1;
      }
    } else {
      imgCounts[fileName] = { count: 1, side: 'corp' };
    }
  });

  const fileNamesToDownload = Object.keys(imgCounts).filter((fileName) => {
    const filePath = TEMP_IMG_PATH + fileName;
    const onExistsMsg = `Found cached copy of ${fileName}, don't download`;
    return fileDoesNotExists(filePath, onExistsMsg, job, 0.01);
  });

  job.log('Fetching images...');
  try {
    await downloadFiles(fileNamesToDownload, job, 0.01);
  } catch (err) {
    console.error(err);
    // TODO cancel job, inform client
  }

  // TODO download card backs

  const dupRunnerFiles = [];
  const dupCorpFiles = [];
  const processedRedPixels = [];
  job.log('Preparing images...');
  console.log('Creating duplicate copies...');
  for (let i = 0; i < Object.keys(imgCounts).length; i += 1) {
    const fileName = Object.keys(imgCounts)[i];
    const { count } = imgCounts[fileName];
    const splitName = fileName.split('.');
    for (let j = 1; j < count; j += 1) {
      const dupName = `${splitName[0]}-${j}.${splitName[1]}`;
      const imgPath = TEMP_IMG_PATH + dupName;
      const onExistsMsg = `Found ${dupName}, a cached copy of ${fileName}, don't duplicate`;
      if (imgCounts[fileName].side === 'runner') {
        dupRunnerFiles.push(dupName);
      }
      if (imgCounts[fileName].side === 'corp') {
        dupCorpFiles.push(dupName);
      }
      // if duplicate missing, make a copy and set the red pixel to make it unique for MPC
      if (fileDoesNotExists(imgPath, onExistsMsg, job, 0.01)) {
        const originalImg = TEMP_IMG_PATH + fileName;
        const msg = `${fileName} being copied to ${dupName}`;
        processedRedPixels.push(setRedPixel(originalImg, imgPath, j, msg));
      }
    }
  }
  await Promise.all(processedRedPixels);
  job.log('Duplicates Ready');
  console.log('Duplicates Ready');

  const allRunnerFiles = fileNamesRunner.concat(dupRunnerFiles);
  allRunnerFiles.forEach((fileName) => {
    fs.copyFileSync(`${TEMP_IMG_PATH}${fileName}`, `${zipDir}runner/${fileName}`);
  });
  const allCorpFiles = fileNamesCorp.concat(dupCorpFiles);
  allCorpFiles.forEach((fileName) => {
    fs.copyFileSync(`${TEMP_IMG_PATH}${fileName}`, `${zipDir}corp/${fileName}`);
  });
  job.log('Adding images to zip file...');
  console.log('Adding images to zip file...');

  const zipFileStream = fs.createWriteStream(zipPath);
  const archive = archiver('zip', { lib: { level: 0 } });

  await new Promise((resolve) => {
    archive.pipe(zipFileStream);
    archive.directory(zipDir, false);
    archive.on('error', (err) => { console.log(err); });
    archive.finalize();
    zipFileStream.on('close', () => {
      console.log(`Zip file ready, ${archive.pointer()} total bytes`);
      job.log(`Zip file ready, ${archive.pointer()} total bytes`);
      job.progress(95);
      resolve();
    });
  });
  // cardBacks.forEach(file => {
  //   archive.file(__dirname + "/static/tmp/zip-cache/" + file, { name: file });
  // });
  // archive.file(__dirname + "/misc/README.txt", { name: "README.txt" });
  return {
    filepath: zipPath,
    hash,
    requestID,
  };
}

module.exports.generatePdf = generatePdf;
module.exports.generateMpc = generateMpc;
